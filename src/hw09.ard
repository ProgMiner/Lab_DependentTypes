\import Data.Maybe
\import Function
\import Function.Meta
\import Logic (Not)
\import Meta
\import Paths
\import Paths.Meta
\import hw06
\import lect06 (Decide, no, yes)
\import lect09

-- 1. Определите отношение многошаговой редукции на Term.

\func Red {V : \Set} : Term V -> Term V -> \Type => ReflTransClosure Red1

-- 2. Стратегия редукции -- это функция, которая каждому терму сопоставляет либо некоторый терм,
--    к которому он редуцируется за 1 шаг, либо доказательство, что таких термов нет.
--    Определите любую стратегию редукции.

\func strategy {V : \Set} (t : Term V) : Decide (\Sigma (s : Term V) (Red1 t s)) \elim t
  | var v => no \case __ \with { | (_, ()) }
  | app (var _) t2 => app-not-lam (var _) t2 (strategy (var _)) (\case __ \with { | (t3, ()) })
  | app (app _ _) t2 => app-not-lam (app _ _) t2 (strategy (app _ _)) (\case __ \with { | (t3, ()) })
  | app (lam t) t2 => yes (_, beta idp idp)
  | app unit t2 => app-not-lam unit t2 (strategy unit) (\case __ \with { | (t3, ()) })
  | lam t => \case strategy t \with {
    | yes (s, r) => yes (lam s, red-lam r)
    | no n => no \case __ \with {
      | (var v, ())
      | (app t1 t2, ())
      | (lam s, red-lam r) => n (s, r)
      | (unit, ())
    }
  }
  | unit => no \case __ \with { | (s, ()) }
  \where {
    \func app-not-lam {V : \Set} (t1 t2 : Term V)
                      (res1 : Decide (\Sigma (s : Term V) (Red1 t1 s)))
                      (q : Not (\Sigma (t3 : Term (Maybe V)) (t1 = lam t3)))
      : Decide (\Sigma (s : Term V) (Red1 (app t1 t2) s))
      => \case res1 \with {
        | yes (s, r) => yes (app s t2, red-left r idp)
        | no n => \case strategy t2 \with {
          | yes (s, r) => yes (app t1 s, red-right idp r)
          | no n1 => no \case __ \with {
            | (_, beta p p1) => q (_, p)
            | (app t3 t4, red-left r p) => n (_, r)
            | (app t3 t4, red-right p r) => n1 (_, r)
          }
        }
      }
  }

-- 3. Докажите, что подтермы достижимого терма достижимы.

\func appAccLeft {V : \Set} {t s : Term V} (a : Acc Red1 (app t s)) : Acc Red1 t \elim a
  | acc f => acc \lam {a'} r => appAccLeft $ f $ red-left r idp

\func appAccRight {V : \Set} {t s : Term V} (a : Acc Red1 (app t s)) : Acc Red1 s \elim a
  | acc f => acc \lam {a'} r => appAccRight $ f $ red-right idp r

\func subLamAcc {V : \Set} {t : Term (Maybe V)} (a : Acc Red1 (lam t)) : Acc Red1 t \elim a
  | acc f => acc \lam {a'} r => subLamAcc $ f $ red-lam r

-- 4. Докажите, что нейтральные термы замкнуты относительно редукций.

\func neutralRed {V : \Set} {t s : Term V} (r : Red1 t s) (n : Neutral t) : Neutral s \elim t, s, r, n
  | app t t1, _, beta p p1, app-neutral n a => \case rewriteF p n
  | app t t1, app s s1, red-left r p, app-neutral n a => app-neutral (neutralRed r n) $ rewriteF p a
  | app t t1, app s s1, red-right p r, app-neutral n (acc f) => app-neutral (rewriteF p n) $ f r

-- 5. Докажите следующую обобщенную лемму о подстановке и выведите из нее обычную версию:
--    если Г, x : A |- b : B и Г |- a : A, то Г |- b[a/x] : B.

\func substLem {U V : \Set} (ctx : U -> Type) (b : Term U) (B : Type) (h : hasType ctx b B)
               (ctx' : V -> Type) (a : U -> Term V) (h' : \Pi (u : U) -> hasType ctx' (a u) (ctx u))
  : hasType ctx' (b >>= a) B \elim b, B, h
  | unit, Unit, unit-type => unit-type
  | var u, B, var-type p => rewriteI p $ h' u
  | app b1 b2, B, app-type h1 h2 => app-type (substLem ctx b1 _ h1 ctx' a h') (substLem ctx b2 _ h2 ctx' a h')
  | lam b, Arr B B1, lam-type h => lam-type $ substLem (maybe B ctx) b _ h (maybe B ctx') (liftM a)
                                            $ \case \elim __ \with {
    | nothing => var-type idp
    | just x => substLem-lemma ctx' (a x) B (ctx x) (h' x)
  }
  \where {
    \func substLem-lemma {V : \Set} (ctx : V -> Type) (t : Term V) (B T : Type) (p : hasType ctx t T)
      : hasType (maybe B ctx) (termMap just t) T \elim t, T, p
      | unit, Unit, unit-type => unit-type
      | var v, T, var-type p => var-type p
      | app t1 t2, T, app-type p1 p2 => app-type (substLem-lemma ctx t1 B _ p1) (substLem-lemma ctx t2 B _ p2)
      | lam t, Arr T1 T2, lam-type p => lam-type $ rewrite (termMap-bind t (MaybeMonad.fmap just))
        $ substLem (maybe T1 ctx) t T2 p (maybe T1 (maybe B ctx)) (var o MaybeMonad.fmap just) \case \elim __ \with {
        | nothing => var-type idp
        | just _ => var-type idp
      }

    \func termMap-bind {V : \Set} (t : Term V) (f : V -> Maybe V)
      : termMap f t = t >>= var o f \elim t
      | unit => idp
      | var _ => idp
      | app t1 t2 => pmap2 app (termMap-bind t1 f) (termMap-bind t2 f)
      | lam t => pmap lam $ termMap-bind t (MaybeMonad.fmap f) *> pmap (t >>=) (ext \case \elim __ \with {
        | nothing => idp
        | just _ => idp
      })
  }

\func substLem1 {U : \Set} (ctx : U -> Type) (A B : Type) (a : Term U) (b : Term (Maybe U))
                (p : hasType (maybe A ctx) b B) (q : hasType ctx a A)
  : hasType ctx (b >>= maybe a var) B
  => substLem (maybe A ctx) b B p ctx (maybe a var) \case \elim __ \with {
    | nothing => q
    | just _ => var-type idp
  }

-- 6. Докажите, что если Г |- a : A и Red a a', то Г |- a' : A

\func red1Lem {V : \Set} {ctx : V -> Type} {a a' : Term V} (r : Red1 a a') {A : Type} (h : hasType ctx a A)
  : hasType ctx a' A \elim a, a', r, A, h
  | app a1 a2, a', beta {f} idp p2, A, app-type (lam-type h1) h2 => rewrite p2 $ substLem1 ctx _ A a2 f h1 h2
  | app _ _, app _ _, red-left r p, _, app-type h1 h2 => app-type (red1Lem r h1) (rewriteI p h2)
  | app _ _, app _ _, red-right p r, _, app-type h1 h2 => app-type (rewriteI p h1) (red1Lem r h2)
  | lam _, lam _, red-lam r, Arr _ _, lam-type h => lam-type $ red1Lem r h

\func redLem {V : \Set} {ctx : V -> Type} {a a' : Term V} (r : Red a a') {A : Type} (h : hasType ctx a A)
  : hasType ctx a' A \elim r
  | rtc-R r => red1Lem r h
  | rtc-refl p => rewriteI p h
  | rtc-trans r1 r2 => redLem r2 (redLem r1 h)

-- Optional
-- 7. Для доказательства typeableInterp понадобится вспомогательное утверждение. Докажите его.

\data HeadRed {V : \Set} (a t s : Term V) \elim t, s
  | app t1 t2, app s1 s2 => headApp (HeadRed a t1 s1) (t2 = s2)
  | app t a', s => headBeta {f : Term (Maybe V)} (a = a') (lam f = t) (f >>= maybe a var = s)

\lemma lam-inv {V : \Set} {t t' : Term (Maybe V)} (p : lam t = lam t') : t = t'
  => pmap (\case \elim __ \with { | lam x => x | _ => unit }) p

\func redInterp {V : \Set} {a t s : Term V} (T : Type) (r : HeadRed a t s) (a-acc : Acc Red1 a) (q : Interp T s)
  : Interp T t \elim t, s, r
  | app t1 t2, app s1 s2, headApp r p => {?}
  | app (lam t1) t2, s, headBeta idp p1 p2 => rewriteI p1 $ cases (T arg addPath) \with {
    | Unit, pT => acc \lam {a'} r => \case \elim a', \elim r \with {
      | a', beta {f1} p p3 => rewrite (p3, inv $ lam-inv p, p2) $ interpAcc _ _ q
      | app (lam a1) a2, red-left (red-lam r) idp => redInterp {_} {a} {_} Unit (headBeta idp idp {?}) a-acc {?}
      | app a1 a2, red-right idp r => {?}
      | app (app a'1 a'2) a'3, red-left () p
      | app (var v) a', red-left () p
      | app unit a', red-left () p
    }
    | Arr T1 T2, pT => \lam {t2} i => {?}
  }
  | app (app t1 t3) t2, s, headBeta p () p2
  | app (var v) t2, s, headBeta p () p2
  | app unit t2, s, headBeta p () p2

-- 8. Докажите typeableInterp из лекции
\func typeableInterp {U V : \Set} (ctx : U -> Type) (env : U -> Term V)
                     (C : \Pi (u : U) -> Interp (ctx u) (env u)) {t : Term U} {T : Type}
                     (p : hasType ctx t T)
  : Interp T (t >>= env) \elim t, T, p
  | unit, Unit, unit-type => acc \case \elim __
  | var v, T, var-type p => {?}
  | app t1 t2, T, app-type p1 p2 => {?}
  | lam t, Arr T1 T2, lam-type p => \lam {t1} i =>
      \let i' => typeableInterp (maybe T1 ctx) (\lam x => liftM env x >>= maybe t1 var) (\case \elim __ \with {
        | nothing => i
        | just u => {?}
      }) p
      \in redInterp T2 (headBeta idp idp (Monad.>>=-assoc _ _ _)) (interpAcc T1 t1 i) i'
